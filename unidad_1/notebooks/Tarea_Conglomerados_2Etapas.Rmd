---
title: "Análisis de Muestreo por Conglomerados en 2 Etapas: Datos Coots"
author: "David Quintela"
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: true
  df_print: paged
  github_document: default
  html_document:
    theme: flatly
    toc: true
    toc_float: true
    code_folding: show
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)

```

## 1. Introducción y Contexto

El objetivo de este estudio es analizar el volumen de los huevos de la negreta Minnedosa (Manitoba), basándonos en el trabajo de Arnold (1991).

Para realizar inferencias estadísticas correctas, es crucial entender el diseño muestral utilizado.

### 1.1 Carga de Librerías y Datos

Primero, cargamos las herramientas necesarias y el conjunto de datos coots proveniente del paquete SDaA.

```{r librerias}
library(SDaA)       # Contiene el dataset 'coots'
library(tidyverse)  # Para manipulación de datos y gráficos
library(gridExtra)  # Para arreglos de gráficos
```

```{r carga_datos}
data(coots)

# Visualizamos las primeras filas para entender la estructura
head(coots)

# Dimensiones del dataset
dim(coots)
```

## 2. Descripción del Diseño de Muestreo

**Tarea 1: Describir cómo este estudio representa un muestreo por conglomerados de 2 etapas.**

Para identificar el diseño, debemos observar la jerarquía de los datos:

 1. **Población Objetivo:** Todos los huevos de negreta en la zona de estudio.

 2. **Unidades Primarias de Muestreo (PSU - Etapa 1):** Las **nidadas (clutches)** o nidos.

    * En lugar de buscar huevos individuales dispersos por todo el pantano (lo cual sería Muestreo Aleatorio Simple y muy costoso), primero se identifican y seleccionan nidos.

 3. **Unidades Secundarias de Muestreo (SSU - Etapa 2):** Los **huevos** dentro de esos nidos.

    * La clave que define la "Segunda Etapa" es que **no se midieron todos los huevos** de cada nido seleccionado. La descripción del problema indica que tenemos una "submuestra de huevos" (específicamente 2 huevos por nidada para este ejercicio).

**Conclusión:**
Es un diseño en **dos etapas** porque hay dos procesos de selección aleatoria (o asumida aleatoria): primero seleccionamos el grupo (nido) y luego seleccionamos individuos dentro del grupo (huevos). Si hubiéramos medido todos los huevos del nido, sería de una sola etapa.

## 3. Exploración de Datos (EDA)

Antes de estimar, realizamos un análisis exploratorio detallado para entender la variabilidad intra e inter nidadas, siguiendo la metodología base del curso.

### 3.1 Inspección Inicial de Variables

Comenzamos con un resumen estadístico general de todas las variables y verificamos la estructura de los conglomerados.

```{r resumen_general}
# Resumen general de las variables
summary(coots)
```

Confirmamos el número total de unidades primarias (nidadas) en la muestra:

```{r conteo_nidadas_unicas}
# Conteo de nidadas únicas
length(unique(coots$clutch))
```

Verificamos el tamaño de muestra dentro de cada conglomerado para confirmar si el diseño es balanceado (mismo número de huevos por nido).

```{r conteo_obs_x_nidada}
# Conteo de observaciones por nidada
coots %>% group_by(clutch) %>% summarise(cant=n())
```

### 3.2 Resumen Estadístico por Nidada

Generamos una tabla detallada con estadísticas descriptivas para cada conglomerado.

```{r resumen_estadistico_x_nidada}
# Crear resumen detallado por nidada (Basado en 50-Conglomerados2.Rmd)
resumen_nidadas <- coots %>%
  group_by(clutch) %>%
  summarise(
    media = mean(volume),          # y_bar_i
    M_i = mean(csize),             # Tamaño del cluster (csize es constante por nido)
    sd = sd(volume),
    min = min(volume),
    max = max(volume),
    rango = diff(range(volume)),
    cant = n()                     # Tamaño de la muestra (m_i = 2)
  ) %>%
  arrange(media) %>%
  mutate(orden = row_number())

# Mostramos las primeras filas del resumen para verificar M_i
head(resumen_nidadas)
```

**Observamos** que M_i (el tamaño real del nido) varía (ej. 6, 9, 10, 11, 12, 13 huevos), aunque nuestra muestra cant sea siempre 2. Esto confirma que debemos ponderar.

### 3.3 Visualización de la Variabilidad

A continuación, replicamos las gráficas de análisis para visualizar la dispersión.

**Figura A: Datos individuales y Medias**
Esta gráfica nos permite ver la dispersión de los huevos (puntos grises) respecto a la media de su nido (rombos rojos).

```{r figura_a}
# Versión 1: Puntos individuales (Figura A)
fig_a <- ggplot(coots, aes(x = as.factor(clutch), y = volume)) +
  geom_point(alpha = 0.6, size = 1.5) +
  geom_line(aes(group = clutch), alpha = 0.3) +
  stat_summary(fun = mean, geom = "point", 
               color = "red", size = 2, shape = 18) +
  labs(
    title = "Gráfica A: Volúmenes de huevo por nidada",
    subtitle = "Puntos: huevos individuales | Diamantes rojos: media por nidada",
    x = "Número de nidada",
    y = "Volumen del huevo"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank()
  )

fig_a
```

**Figura B: Distribución de las Medias**
Esta gráfica aísla las medias de cada nido. La dispersión que vemos aquí representa la **varianza entre conglomerados**, que es el componente principal de nuestro error de muestreo.

```{r figura_b}
# Figura B: Solo medias (Basado en 50-Conglomerados2.Rmd)
fig_b <- ggplot(resumen_nidadas, aes(x = clutch, y = media)) +
  geom_point(alpha = 0.7, size = 1.5, color = "darkblue") +
  geom_hline(yintercept = mean(resumen_nidadas$media), 
             linetype = "dashed", color = "red") +
  labs(
    title = "Figura B: Medias por nidada",
    subtitle = "Visualización de la variabilidad ENTRE conglomerados",
    x = "Número de nidada",
    y = "Volumen medio del huevo"
  ) +
  theme_minimal()

fig_b
```

## 4. Estimación Puntual

**Tarea 2: Estimar el promedio poblacional del volumen del huevo.**

Al tener conglomerados de distintos tamaños ($M_i$ variable), el promedio simple de las medias de los nidos es un estimador sesgado. Debemos usar el Estimador de Razón ($\hat{\bar{Y}}_R$), que pondera cada media por el tamaño de su nido.

$$ \hat{\bar{Y}}{R} = \frac{\sum{i=1}^n M_i \bar{y}i}{\sum{i=1}^n M_i} $$
Verificamos que esto es igual al promedio de los promedios de las nidadas (debido al tamaño de muestra constante $m_i = 2$).

```{r promedio_estimado_ponderado}
# Numerador: Suma de los totales estimados por nido (M_i * media_i)
numerador <- sum(resumen_nidadas$M_i * resumen_nidadas$media)

# Denominador: Suma de los tamaños de los nidos
denominador <- sum(resumen_nidadas$M_i)

# Estimador de Razón
promedio_ponderado <- numerador / denominador

cat("El volumen promedio estimado (Ponderado) es:", round(promedio_ponderado, 4))
```

Comparación con el promedio simple (Sesgado)

```{r comparacion_promedio_simple}
promedio_simple <- mean(resumen_nidadas$media)
cat("Promedio Simple (Sin ponderar):", round(promedio_simple, 4), "\n")
cat("Diferencia:", round(promedio_ponderado - promedio_simple, 4))
```
## 5. Estimación del Error Estándar (SE)

**Tarea 3: Investigar y calcular el error estándar del estimador.**

Dado que usamos un estimador de razón, el error estándar también cambia. Ya no usamos la varianza simple de las medias, sino la varianza de los residuos ponderados.

La fórmula aproximada para el Error Estándar del estimador de razón en muestreo por conglomerados es:

$$ SE(\hat{\bar{Y}}_R) \approx \frac{1}{\bar{M}} \sqrt{\frac{s_r^2}{n}} $$

Donde:

 * $\bar{M}$ es el tamaño promedio de los nidos en la muestra.

 * $s_r^2$ es la varianza de los valores $u_i$, donde $u_i = M_i (\bar{y}_i - \hat{\bar{Y}}_R)$.

 * $n$ es el número de nidos.

Este método captura la variabilidad "entre" conglomerados ajustada por su tamaño.

```{r estimacion_SE}
# 1. Definir n (número de nidos)
n_clutches <- nrow(resumen_nidadas)

# 2. Calcular M promedio (tamaño promedio del nido)
M_bar <- mean(resumen_nidadas$M_i)

# 3. Calcular la variable auxiliar u_i (Residuos ponderados)
# u_i representa cuánto se desvía el total del nido i respecto a lo esperado por el promedio global
resumen_nidadas <- resumen_nidadas %>%
  mutate(u_i = M_i * (media - promedio_ponderado))

# 4. Calcular la varianza de u_i (s_r^2)
s2_r <- var(resumen_nidadas$u_i)

# 5. Calcular Error Estándar (SE)
error_estandar_ratio <- (1 / M_bar) * sqrt(s2_r / n_clutches)

cat("Número de nidadas (n):", n_clutches, "\n")
cat("Tamaño promedio del nido (M_bar):", round(M_bar, 2), "\n")
cat("Error Estándar (SE) corregido:", round(error_estandar_ratio, 4))
```

**Comparación de Errores**
```{r}
# Recalculamos el anterior para comparar
sd_entre_nidadas <- sd(resumen_nidadas$media)
se_simple <- sd_entre_nidadas / sqrt(n_clutches)

cat("SE (Método Simple - Incorrecto para M variable):", round(se_simple, 4), "\n")
cat("SE (Método de Razón - Correcto):", round(error_estandar_ratio, 4), "\n")
```

**Interpretación:** El cálculo correcto ajusta la incertidumbre considerando que los nidos más grandes tienen más peso en la estimación final.

## 6. Intervalo de Confianza

Finalmente, reportamos el resultado con un intervalo de confianza al 95%.

```{r intervalo_confianza}
alpha <- 0.05
t_value <- qt(1 - alpha/2, df = n_clutches - 1) 

lim_inf <- promedio_ponderado - t_value * error_estandar_ratio
lim_sup <- promedio_ponderado + t_value * error_estandar_ratio

cat("Intervalo de Confianza 95%: [", round(lim_inf, 3), ", ", round(lim_sup, 3), "]")
```

**Reporte Final:**
Utilizando un estimador de razón para corregir por los tamaños variables de las nidadas, se estima que el volumen promedio de los huevos en la población es de `r round(promedio_ponderado, 3)` pulgadas cúbicas, con un error estándar de `r round(error_estandar_ratio, 3)`.
